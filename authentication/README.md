# Authentication


### Auth0 vs OAuth 2.0
* OAuth 2.0 is a protocol for authentication and authorization without needing credentials
* Auth0 is an organisation and software that implements the OAuth2 protocol


### OAuth 2.0 / Bearer Access Tokens / JWT
* The most common way of accessing OAuth 2.0 APIs is using a "Bearer Token"
* Tokens usually expire after a given time
* Bearer tokens does not require cryptographic signing of each request
* All API requests must be made over HTTPS since it contains a plaintext token
* Token-based authentication is implemented by generating a token when the user authenticates and then setting that token in the authorization header of each subsequent request to your API.
    * Should be standardised such as JSON Web Tokens (JWT)
* A single string which acts as the authentication of the API request, sent in an HTTP “Authorization” header
* It is usually generated by the server in response to a login request
* The client must send the bearer token in the authorization header when making requests
* Bearer Access Tokens is used in OAuth 2.0
* The bad side of a bearer token is that anyone that has the token can use it
* JSON Web Tokens (JWT)
* The purpose of JWT is to ensure who you are talking to
* JWT is **not encrypted**, but it is **encoded** in Base64 URL
    * Base64 URL is the same as Base64, but mapping "+" to "-" and "/" to "_".
* JWT is created using a secret key
* JWT is an encoded format of a JSON.
    * **x**: First part of the header
    * **y**: Second part of the payload
    * **z**: Third part of the *secret signature*
```js
Header.Payload.Signature
Signature = Encrypt(Base64URL(Header), Base64URL(Payload), secret)
```
* **Signing the Json Web Token**: Means using the header, payload, and secret to create the signature, which outputs the JWT.
* The idea is that even if an attacker changes the header or the data, the signature cannot be reproduced because it requires the secret key.
* The secret key is the most important part, a good advice is to use a 256bit key
* The server validates the JWT when it is recieved by calculating the JWT signature using the secret key. If the signature is the same, then the message is validated.
* The more data we want to encode here the bigger the JWT, since the payload is part of the JWT.
* JWT is sent in plain text
* JWT is a stateless session
* JWT is a bearer token since it is a string used for authorization.


### Security in OAuth 2.0
* Have a short Time To Live (TTL).
* The signing key must be keps secure like any other credentials.
* Ensuring that tokens are generated within a secured server is recommended for extra security.
* Use valid tokens until they expire instead of generated new ones all the time.
* Do not send tokens over connections that are not secure.
* Make sure tokens and other sensitive data cannot be read by cross-site scripting (XSS) and can't be read by malicious JavaScript.
* Access tokens and (optionally) refresh tokens are needed when we create tokens on server site.
* Some implementations are prune to Cross Site Scripting (XSS). If tokens are handled or accessible by the browser, there is a risk that a XSS attack can lead to token exfiltration.


### JWT Signing Algorithms
The fact that a JWT is signed, it does not mean it is encrypted, it just act as a stamp for the message.
Common signing algorithms are:
* **HS256 : HMAC + SHA-265**: relies on the shared symmetrical key. The secret must be shared between the sender and recipient.
* **RS256 / RSASSA + SHA-256**: relies on private/public RSA key pair, but it may overload the network and use more CPU
* **ES256 : ECDSA using p-265 and SHA-265** relies on private/public RSA key pair but much shorter
* For ES256, the private key can be kept secret, and the public key can be freely issued.


### Authorization Code Flow
See: https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow
The following flow should NOT be used by edge applications such as single page web application (React/javascript) or native mobile apps (iOS/Android). 
This is because `Authorization Code Flow` is prune to potentially leak the `Authorization Code` to a malicious attacker.
This should be used within secure environments:
1. The end user clicks Login
2. The backend gets notified and triggers the Authorization Server's login and authorization prompt that will be presented to the end user
3. The end user consents and login in
4. The Authorization Server gets notified and sends the `authorization code` to the backend
5. The backend creates the JWT using the `secret ID`, the `client ID` and the `authorization code` within the given JWT Signing Algorithm and sends the JWT to the Authorization Server for validation.
6. The Authorization Server validates the JWT by reconstructing it, and on succes returns an `access token` that will expire after a given time. This `access token` are used as authentication to fetch data from the API you wishs to fetch from.
7. The backend can then fetch from the API by including the `access token` in the header of the request.


### Authorization Code Flow with Proof Key for Code Exchange (PKCE)
See: https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-proof-key-for-code-exchange-pkce
`Authorization Code Flow with Proof Key for Code Exchange (PKCE)`, (pronounced "pixie"), should be used instead of `Authorization Code Flow` when using:
    * Web browser - single page apps (example, React application).
    * Native mobile app (iOS/Android):
Web browsers and native mobile apps should not be used to store the `access token` since then the token can be leaked.
`PKCE` is essentially an extension to the `Authorization Code flow` to prevent Cross-Site Request Forgery (CSRF) and authorization code injection attacks.
By using `PKCE`, the `access token` will not exposed on the client side.
The difference between `PKCE` and `Authorization Code Flow` is that the client generates a `code_verifier` and a `code_challenge`.
