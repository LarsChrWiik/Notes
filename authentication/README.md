# Authentication


### Auth0 vs OAuth 2.0
* OAuth 2.0 is a protocol for authentication and authorization without needing credentials
* Auth0 is an organisation and software that implements the OAuth2 protocol


### Termonology
And examples from Open Banking applications.
* **Roles**:
    * **Resource owner**: the User that gives access to their account containing their resources, such as user data points. The user can allow other systems to act on behalf of them.
        * Example: The person called `Joe`
    * **Resource server** Resource server is the server that contains the user's information that is accessed by third party applications.
        * Example: The open banking provider called `Tink`
    * **Authorization server**: The server that displays the OAuth prompt where the user approves the accress grant to the application. (In some cases, this is the same as the Resource server).
        * Example: The bank called `Bank1`
    * **Client** the application that act or read data points based on the users behaf.
        * There are two types as clients:
        * **Confidential Client**: A client that is able to keep secrets securly.
            * Example: A secure application within the backend server.
        * **Public Clients**: A client that cannot keep secrets securly.
            * Example: A web browser or a mobile app.
* **Access Token**: The string used when making authenticated requests to the API. It represents a successive authorization. It has a duration of access and a scope.
* **Refresh Token**: a string that is used to get a new access token when an access token expires.
* **Authorization Code**: An authorization code is an intermediate token used in the server-side app flow that is provided after authentication and can thereafter be exchanged to an access token.


### The main idea with OAuth and Access tokens
The main idea is to first ensure that we are communicating between trusted parties (user authentication), and then establish a way to know if the message is sent from the authenticated user - and this "stamp of approval" is the access token. This is because the access token


 contains the encoded secret key and authentication code and the message, so without the secret key and the code, then an attacker cannot change the payload.





### Basic vs. Bearer vs. Digest authentication
* **Basic**: authenticate using username and secret.
* **Digest** authenticate using username and secret. Digest auth is more secure as it don't send username and secret as plain text. MD5 cryptographic hashing.
* **Bearer**: authenticate using access_token.


### Bearer Access Tokens
* The most common way of accessing OAuth 2.0 APIs is using a `Bearer Token`
* The purpose of an access token is to show you have been authenticated
* Bearer tokens does not require cryptographic signing of each request (Unlike JWT)
* Tokens usually expire after a given time
* All API requests must be made over HTTPS since it contains a plaintext token
* Token-based authentication is implemented by generating a token when the user authenticates and then setting that token in the authorization header of each subsequent request to your API.
* A single string which acts as the authentication of the API request, sent in an HTTP “Authorization” header
* It is usually generated by the server in response to a login request
* The client must send the bearer token in the authorization header when making requests
* Bearer Access Tokens is used in OAuth 2.0
* The bad side of a bearer token is that anyone that has the token can use it


### Confidential and Public Applications
Confidential applications is able to hold credentials (client ID and secret key) securly.
* **Confidential applications**: Can use `Client Credentials Flow`.
* **Non-confidential applications**: Should use `Authorization Code Flow` or `Authorization Code Flow with (PKCE)`.


### OAuth - Client Credentials Flow
Called `client_secret_post`

The simples way of authenticating, and should only be used B2B in machine to machine applications.
Client ID and Client Secret to authenticate themselves and get a token.
As the OAuth desciption states:
```
The client credentials grant type MUST only be used by confidential clients.
```


### OAuth - Authorization Code Flow
See:
* https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow

The following flow should NOT be used by edge applications such as single page web application (React/javascript) or native mobile apps (iOS/Android). 
This is because `Authorization Code Flow` is prune to potentially leak the `Authorization Code` to a malicious attacker.
This should be used within secure environments:
1. The end user clicks Login
2. The backend gets notified and triggers the Authorization Server's login and authorization prompt that will be presented to the end user
3. The end user consents and login in
4. The Authorization Server gets notified and sends the `authorization code` to the backend
5. The backend creates the JWT using the `secret ID`, the `client ID` and the `authorization code` within the given JWT Signing Algorithm and sends the JWT to the Authorization Server for validation.
6. The Authorization Server validates the JWT by reconstructing it, and on succes returns an `access token` that will expire after a given time. This `access token` are used as authentication to fetch data from the API you wishs to fetch from.
7. The backend can then fetch from the API by including the `access token` in the header of the request.


### OAuth - Authorization Code Flow with Proof Key for Code Exchange (PKCE)
See: 
* https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-proof-key-for-code-exchange-pkce
* https://oauth.net/2/pkce/

`Authorization Code Flow with Proof Key for Code Exchange (PKCE)`, (pronounced "pixie"), should be used instead of `Authorization Code Flow` when using:
    * Web browser - single page apps (example, React application).
    * Native mobile app (iOS/Android):
And it is also recommended to use it within `server applications` to prevent `CSRF` and `authorization code injection attacks`.

PKCE is not a replacement for client secrets. It is a mitigation against stolen authorization codes that is particularly useful when a client application cannot keep a secret.

Web browsers and native mobile apps should not be used to store the `access token` since then the token can be leaked.
`PKCE` is essentially an extension to the `Authorization Code flow` to prevent Cross-Site Request Forgery (CSRF) and authorization code injection attacks.
By using `PKCE`, the `access token` will not exposed on the client side.
The difference between `PKCE` and `Authorization Code Flow` is that the client generates a `code_verifier` and a `code_challenge`.


### JWT
* JSON Web Tokens (JWT)
* The purpose of JWT is to ensure who you are talking to
* JWT is `not encrypted`, but it is `encoded` in Base64 URL
    * Base64 URL is the same as Base64, but mapping "+" to "-" and "/" to "_".
* JWT is created using a secret key
* `Signing the Json Web Token`: Means using the header, payload, and secret to create the signature, which outputs the JWT.
* The idea is that even if an attacker changes the header or the data, the signature cannot be reproduced because it requires the secret key.
* The `secret key` is the most important part, a good advice is to use a 256bit key
* The server validates the JWT when it is recieved by calculating the JWT signature using the secret key. If the signature is the same, then the message is validated.
* The more data we want to encode here the bigger the JWT, since the payload is part of the JWT.
* JWT is sent in `plain text`
* JWT is a stateless session
* JWT is a bearer token since it is a string used for authorization.
* JWT is an encoded format of a JSON.
    * **x**: First part of the header
    * **y**: Second part of the payload
    * **z**: Third part of the *secret signature*
```
xxxxx.yyyyy.zzzzz
```
Example:
```js
// Header
{
  "alg": "HS256",
  "typ": "JWT"
}
// Payload
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
// Signature
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  "mySecret"
)

// Result:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```


### When to use JWT?
JWT is best used whenever you want to send some information to an untrusted client, in such a way that that client can verify the information contained in the payload themselves.


### Security in OAuth 2.0
* Have a short Time To Live (TTL).
* The signing key must be keps secure like any other credentials.
* Ensuring that tokens are generated within a secured server is recommended for extra security.
* Use valid tokens until they expire instead of generated new ones all the time.
* Do not send tokens over connections that are not secure.
* Make sure tokens and other sensitive data cannot be read by cross-site scripting (XSS) and can't be read by malicious JavaScript.
* Access tokens and (optionally) refresh tokens are needed when we create tokens on server site.
* Some implementations are prune to Cross Site Scripting (XSS). If tokens are handled or accessible by the browser, there is a risk that a XSS attack can lead to token exfiltration.


### JWT Signing Algorithms
The fact that a JWT is signed, it does not mean it is encrypted, it just act as a stamp for the message.
Common signing algorithms are:
* **HS256 : HMAC + SHA-265**: relies on the shared symmetrical key. The secret must be shared between the sender and recipient.
* **RS256 / RSASSA + SHA-256**: relies on private/public RSA key pair, but it may overload the network and use more CPU
* **ES256 : ECDSA using p-265 and SHA-265** relies on private/public RSA key pair but much shorter
* For ES256, the private key can be kept secret, and the public key can be freely issued.
